.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "CWB::Web::Query 3"
.TH CWB::Web::Query 3 "2022-05-07" "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  CWB::Web::Query \- A simple CQP front\-end for CGI scripts
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use CWB::Web::Query;
\&
\&  # typically, a query object is used for a single query only
\&  $query = new CWB::Web::Query \*(AqHANSARD\-E\*(Aq;
\&
\&  # install HTML\-producing error handler
\&  $query\->on_error(sub{grep {print "<h2>$_</h2>\en"} @_});
\&
\&  # result output settings
\&  $query\->context(\*(Aq1 s\*(Aq, \*(Aq1 s\*(Aq);    # left & right context
\&  $query\->attributes(\*(Aqword\*(Aq, \*(Aqpos\*(Aq, \*(Aqs\*(Aq); # show which attributes
\&  $query\->alignments(\*(Aqhansard\-f\*(Aq);  # aligned corpora to show
\&  $query\->structures(\*(Aqsitting\*(Aq);    # return annotated values of regions
\&  $query\->reduce(10);               # return at most 10 matches
\&
\&  # run query \- returns list of result structs
\&  @matches = $query\->query("[pos=\*(AqJJ\*(Aq] [pos=\*(AqNN\*(Aq & lemma=\*(Aqdog\*(Aq]");
\&  $nr_matches = @matches;
\&
\&  # typical result processing loop
\&  for ($i = 0; $i < $nr_matches; $i++) {
\&    $nr = $i + 1;               # match number
\&    $m = $matches[$i];          # result struct
\&    $m\->{\*(Aqcpos\*(Aq};               # corpus position of match
\&    $m\->{\*(Aqkwic\*(Aq}\->{\*(Aqleft\*(Aq};     # left context (HTML encoded)
\&    $m\->{\*(Aqkwic\*(Aq}\->{\*(Aqmatch\*(Aq};    # match        ( ~      ~   )
\&    $m\->{\*(Aqkwic\*(Aq}\->{\*(Aqright\*(Aq};    # right context( ~      ~   )
\&    $m\->{\*(Aqhansard\-f\*(Aq};          # aligned region
\&    $m\->{\*(Aqdata\*(Aq}\->{\*(Aqsitting\*(Aq};  # annotation of structural region
\&  }
\&
\&  # closes down CQP server & deallocates memory
\&  undef $query;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fICWB::Web::Query\fR module is a simplified \s-1CQP\s0 front-end intended for
use in \s-1CGI\s0 scripts. Typically, a \s-1CGI\s0 script will create a
\&\fICWB::Web::Query\fR object for a single query. It is possible to reuse
query objects for further queries on the same corpus, though.
.SH "ERRORS"
.IX Header "ERRORS"
If the \fICWB::Web::Query\fR module encounters an error condition, an error
message is printed on \f(CW\*(C`STDERR\*(C'\fR and the program is terminated. A user-defined
error handler can be installed with the \fI\f(BIon_error()\fI\fR method. In this case,
the error callback function is passed the error message generated by the module
as a list of strings.
.SH "CORPUS REGISTRY"
.IX Header "CORPUS REGISTRY"
If you need to use a registry other than the default corpus registry,
set the variable
.PP
.Vb 1
\&  $CWB::Web::Query::Registry = "/path/to/my/registry";
.Ve
.PP
This will affect all new \fICWB::Web::Query\fR objects.
.SH "RESULT STRUCTURE"
.IX Header "RESULT STRUCTURE"
The query module's \fI\f(BIquery()\fI\fR method returns a list of \fIresult structs\fR 
corresponding to the matches of the query. A \s-1CGI\s0 script will usually
iterate through the list with a loop similar to this:
.PP
.Vb 4
\&    @result_list = $query\->query(...);
\&    foreach $m (@result_list) {
\&      # code for processing match data in result struct $m 
\&    }
.Ve
.PP
A \fIresult struct\fR \f(CW$m\fR has the following fields:
.ie n .IP "$m\->{'cpos'}" 4
.el .IP "\f(CW$m\fR\->{'cpos'}" 4
.IX Item "$m->{'cpos'}"
\&\fICorpus position\fR of the first token in this match.
.ie n .IP "$m\->{'kwic'}" 4
.el .IP "\f(CW$m\fR\->{'kwic'}" 4
.IX Item "$m->{'kwic'}"
\&\fILeft context\fR, \fImatch\fR, and \fIright context\fR are returned
in the subfields
.Sp
.Vb 3
\&   $m\->{\*(Aqkwic\*(Aq}\->{\*(Aqleft\*(Aq}
\&   $m\->{\*(Aqkwic\*(Aq}\->{\*(Aqmatch\*(Aq}
\&   $m\->{\*(Aqkwic\*(Aq}\->{\*(Aqright\*(Aq}
.Ve
.Sp
as HTML-encoded text. Neither the match nor \fIkeyword\fR or \fItarget\fR 
fields specified in the query are highlighted.
.ie n .IP "$m\->{$aligned_corpus}" 4
.el .IP "\f(CW$m\fR\->{$aligned_corpus}" 4
.IX Item "$m->{$aligned_corpus}"
For each aligned corpus \f(CW$aligned_corpus\fR passed to the \fI\f(BIalignments()\fI\fR method,
the field \f(CW\*(C`$m\-\*(C'\fR{$aligend_corpus}> contains the region aligned to the match
as HTML-encoded text.
.ie n .IP "$m\->{'data'}" 4
.el .IP "\f(CW$m\fR\->{'data'}" 4
.IX Item "$m->{'data'}"
The annotated values of structural attributes specified with the 
\&\fI\f(BIstructures()\fI\fR method are returned in accordingly named subfields
of the 'data' field. The returned values are \fInot\fR HTML-encoded.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$query = new CWB::Web::Query $corpus;" 4
.el .IP "\f(CW$query\fR = new CWB::Web::Query \f(CW$corpus\fR;" 4
.IX Item "$query = new CWB::Web::Query $corpus;"
Create \fICWB::Web::Query\fR object for \s-1CQP\s0 queries on corpus \f(CW$corpus\fR.
.ie n .IP "$query\->on_error(\e&error_handler);" 4
.el .IP "\f(CW$query\fR\->on_error(\e&error_handler);" 4
.IX Item "$query->on_error(&error_handler);"
Install error callback function. \f(CW\*(C`error_handler()\*(C'\fR is a user-defined
subroutine, which will usually generate an \s-1HTML\s0 document from the
error message passed by the \fICWB::Web::Query\fR module. A typical error
callback might look like this:
.Sp
.Vb 6
\&    sub error_handler {
\&      my @msg = @_;  # @msg holds the lines of the error message
\&      print "<html><body><h1>ERROR</h1>\en";
\&      grep { print "$_<br>\en" } @msg;  # print @msg as individual lines
\&      print "</body></html>\en";
\&    }
.Ve
.ie n .IP "$query\->context($left, $right);" 4
.el .IP "\f(CW$query\fR\->context($left, \f(CW$right\fR);" 4
.IX Item "$query->context($left, $right);"
Left and right context returned by the \fI\f(BIquery()\fI\fR method. \f(CW$left\fR and
\&\f(CW$right\fR are passed to \s-1CQP\s0 for processing and hence must be specified
in \s-1CQP\s0 format. Typical values are
.Sp
.Vb 1
\&    $query\->context("10 words", "10 words");
.Ve
.Sp
for fixed number of tokens and
.Sp
.Vb 1
\&    $query\->context("1 s", "1 s");
.Ve
.Sp
to retrieve entire sentences.
.ie n .IP "$query\->attributes($att1, $att2, ...);" 4
.el .IP "\f(CW$query\fR\->attributes($att1, \f(CW$att2\fR, ...);" 4
.IX Item "$query->attributes($att1, $att2, ...);"
Select attributes to display. Can include \fIboth\fR positional and
structural attributes.
.ie n .IP "$query\->alignments($corpus, ...);" 4
.el .IP "\f(CW$query\fR\->alignments($corpus, ...);" 4
.IX Item "$query->alignments($corpus, ...);"
Specifiy one or more aligned corpora. Aligned regions in those 
corpora will be returned as HTML-encoded strings in the fields
.Sp
.Vb 2
\&     $m\->{$corpus};
\&     ...
.Ve
.Sp
of a result struct \f(CW$m\fR.
.ie n .IP "$query\->structures($att1, $att2, ...);" 4
.el .IP "\f(CW$query\fR\->structures($att1, \f(CW$att2\fR, ...);" 4
.IX Item "$query->structures($att1, $att2, ...);"
Specify structural attributes with annotated values. The annotated
value of the \f(CW$att1\fR region containing the match will be returned
in
.Sp
.Vb 1
\&    $m\->{\*(Aqdata\*(Aq}\->{$att1}
.Ve
.Sp
as plain text for further processing etc.
.ie n .IP "$query\->reduce($n);" 4
.el .IP "\f(CW$query\fR\->reduce($n);" 4
.IX Item "$query->reduce($n);"
Return at most \f(CW$n\fR matches randomly selected from corpus (hence repeated
execution of the same query will produce different results). Deactivate
with
.Sp
.Vb 1
\&    $query\->reduce(0);
.Ve
.Sp
This method uses \s-1CQP\s0's \fIreduce\fR command.
.ie n .IP "$query\->cut($n);" 4
.el .IP "\f(CW$query\fR\->cut($n);" 4
.IX Item "$query->cut($n);"
Similar to the \fI\f(BIreduce()\fI\fR method, this returns the \fIfirst\fR \f(CW$n\fR matches
found in the corpus. The \fI\f(BIcut()\fI\fR method uses \s-1CQP\s0's \fIcut\fR operator and 
is faster on slow machines. However, \fI\f(BIreduce()\fI\fR will usually yield more
balanced results. Sometimes a combination of both can be useful, such as
.Sp
.Vb 2
\&    $query\->cut(1000);     # stop after first 1000 matches,
\&    $query\->reduce(50);    # but return only 50 of them
.Ve
.ie n .IP "@results = $query\->query($cqp_query);" 4
.el .IP "\f(CW@results\fR = \f(CW$query\fR\->query($cqp_query);" 4
.IX Item "@results = $query->query($cqp_query);"
Executes \s-1CQP\s0 query and returns a list of matches. See \*(L"\s-1RESULT STRUCTURE\*(R"\s0 
for the format of the \f(CW@results\fR list.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1999\-2020 Stefan Evert [http::/purl.org/stefan.evert]
.PP
This software is provided \s-1AS IS\s0 and the author makes no warranty as to
its use and performance. You may use the software, redistribute and
modify it under the same terms as Perl itself.
