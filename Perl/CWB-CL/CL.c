/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.45 from the
 * contents of CL.xs. Do not edit this file, edit CL.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "CL.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* #include "ppport.h" */

#include <cwb/cl.h>
#include <stdio.h>

/*
  ********* C segment (preamble) **********
*/ 

typedef Attribute * PosAttrib;  /* allows XS to check that attribute pointer belongs to approriate class */
typedef Attribute * StrucAttrib;
typedef Attribute * AlignAttrib;

int last_cl_error = CDA_OK; /* keep track of last error (cl_errno variable) in vectorised functions */
#define CWB_CL_INVALID_ARG 1 /* internal error codes used by the CWB::CL module */

int strict_mode = 0; /* in strict mode, every CL or argument error will cause the interface to croak() */

const char*
cwb_cl_error_message(int error_code) {
  if (error_code == CWB_CL_INVALID_ARG) { 
    return "CWB::CL: invalid argument encountered";
  }
  else {
    return cl_error_string(error_code);
  }
}

void
croak_on_error(int error_code) {
  croak("%s (aborted)", cwb_cl_error_message(error_code));
}

static int
not_here(s)
char *s;
{
  croak("%s not implemented on this architecture", s);
  return -1;
}

static double
constant(name)
char *name;
{
  errno = 0;
  switch (*name) {
  case 'A':
    if (strEQ(name, "ATTAT_FLOAT"))
      return ATTAT_FLOAT;
    if (strEQ(name, "ATTAT_INT"))
      return ATTAT_INT;
    if (strEQ(name, "ATTAT_NONE"))
      return ATTAT_NONE;
    if (strEQ(name, "ATTAT_PAREF"))
      return ATTAT_PAREF;
    if (strEQ(name, "ATTAT_POS"))
      return ATTAT_POS;
    if (strEQ(name, "ATTAT_STRING"))
      return ATTAT_STRING;
    if (strEQ(name, "ATTAT_VAR"))
      return ATTAT_VAR;
    if (strEQ(name, "ATT_ALIGN"))
      return ATT_ALIGN;
    if (strEQ(name, "ATT_ALL"))
      return ATT_ALL;
    if (strEQ(name, "ATT_DYN"))
      return ATT_DYN;
    if (strEQ(name, "ATT_NONE"))
      return ATT_NONE;
    if (strEQ(name, "ATT_POS"))
      return ATT_POS;
    if (strEQ(name, "ATT_REAL"))
      return ATT_REAL;
    if (strEQ(name, "ATT_STRUC"))
      return ATT_STRUC;
    break;
  case 'C':
    if (strEQ(name, "CDA_EALIGN"))
      return CDA_EALIGN;
    if (strEQ(name, "CDA_EARGS"))
      return CDA_EARGS;
    if (strEQ(name, "CDA_EATTTYPE"))
      return CDA_EATTTYPE;
    if (strEQ(name, "CDA_EBADREGEX"))
      return CDA_EBADREGEX;
    if (strEQ(name, "CDA_EBUFFER"))
      return CDA_EBUFFER;
    if (strEQ(name, "CDA_EFSETINV"))
      return CDA_EFSETINV;
    if (strEQ(name, "CDA_EIDORNG"))
      return CDA_EIDORNG;
    if (strEQ(name, "CDA_EIDXORNG"))
      return CDA_EIDXORNG;
    if (strEQ(name, "CDA_ENODATA"))
      return CDA_ENODATA;
    if (strEQ(name, "CDA_ENOMEM"))
      return CDA_ENOMEM;
    if (strEQ(name, "CDA_ENOSTRING"))
      return CDA_ENOSTRING;
    if (strEQ(name, "CDA_ENULLATT"))
      return CDA_ENULLATT;
    if (strEQ(name, "CDA_ENYI"))
      return CDA_ENYI;
    if (strEQ(name, "CDA_EOTHER"))
      return CDA_EOTHER;
    if (strEQ(name, "CDA_EPATTERN"))
      return CDA_EPATTERN;
    if (strEQ(name, "CDA_EPOSORNG"))
      return CDA_EPOSORNG;
    if (strEQ(name, "CDA_EREMOTE"))
      return CDA_EREMOTE;
    if (strEQ(name, "CDA_ESTRUC"))
      return CDA_ESTRUC;
    if (strEQ(name, "CDA_EINTERNAL"))
      return CDA_EINTERNAL;
    if (strEQ(name, "CDA_OK"))
      return CDA_OK;
    if (strEQ(name, "CL_STRING_CANONICAL_STRDUP"))
      return CL_STRING_CANONICAL_STRDUP;
    break;
  case 'I':
    if (strEQ(name, "IGNORE_CASE")) /* regexp flags */
      return IGNORE_CASE;
    if (strEQ(name, "IGNORE_DIAC")) 

      return IGNORE_DIAC;
    if (strEQ(name, "IGNORE_REGEX"))
      return IGNORE_REGEX;
    break;
  case 'R':
    if (strEQ(name, "REQUIRE_NFC"))
      return REQUIRE_NFC;
    break;
  case 'S':
    if (strEQ(name, "STRUC_INSIDE")) /* s-attribute region boundaries */
      return STRUC_INSIDE;
    if (strEQ(name, "STRUC_LBOUND")) 
      return STRUC_LBOUND;
    if (strEQ(name, "STRUC_RBOUND")) 
      return STRUC_RBOUND;
    break;
  }

  errno = EINVAL; /* name matches none of the known constants */
  return 0;
}

/*
  ********* XS segment (preamble) **********
*/ 

#line 167 "CL.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 311 "CL.c"

XS_EUPXS(XS_CWB__CL_cwb_cl_error_message); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cwb_cl_error_message)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "error_code");
    {
	int	error_code = (int)SvIV(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = cwb_cl_error_message(error_code);
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_error_message); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_error_message)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 168 "CL.xs"
    int error_code;
#line 343 "CL.c"
	const char *	RETVAL;
	dXSTARG;
#line 170 "CL.xs"
    /* return string with last CL error encountered in last method call ("" if last call was successful) */
    error_code = (last_cl_error != CDA_OK) ? last_cl_error : cl_errno; /* after simple function invocation, use CL library error status */
    if (error_code == CDA_OK) {
      RETVAL = "";
    }
    else {
      RETVAL = cwb_cl_error_message(error_code); /* returns pointer to string constant */
    }
#line 355 "CL.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_set_strict_mode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_set_strict_mode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "on_off");
    {
	int	on_off = (int)SvIV(ST(0))
;
#line 185 "CL.xs"
    strict_mode = on_off;
#line 375 "CL.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_CWB__CL_get_strict_mode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_get_strict_mode)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 190 "CL.xs"
    RETVAL = strict_mode;
#line 392 "CL.c"
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_constant)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	char *	name = (char *)SvPV_nolen(ST(0))
;
	double	RETVAL;
	dXSTARG;

	RETVAL = constant(name);
	XSprePUSH;
	PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_new_corpus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_new_corpus)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "registry_dir, registry_name");
    {
	char *	registry_dir = (char *)SvPV_nolen(ST(0))
;
	char *	registry_name = (char *)SvPV_nolen(ST(1))
;
	Corpus *	RETVAL;
#line 203 "CL.xs"
    last_cl_error = CDA_OK;
#line 434 "CL.c"

	RETVAL = cl_new_corpus(registry_dir, registry_name);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "CorpusPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_corpus_charset_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_corpus_charset_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "corpus");
    {
	Corpus *	corpus;
	const char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "CorpusPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    corpus = INT2PTR(Corpus *,tmp);
	}
	else {
		const char* refstr = SvROK(ST(0)) ? "" : SvOK(ST(0)) ? "scalar " : "undef";
	    Perl_croak_nocontext("%s: Expected %s to be of type %s; got %s%" SVf " instead",
			"CWB::CL::cl_corpus_charset_name",
			"corpus", "CorpusPtr",
			refstr, ST(0)
		);
	}
;
#line 209 "CL.xs"
    RETVAL = cl_charset_name(cl_corpus_charset(corpus));
#line 474 "CL.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_delete_corpus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_delete_corpus)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "corpus");
    {
	Corpus *	corpus;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "CorpusPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    corpus = INT2PTR(Corpus *,tmp);
	}
	else {
		const char* refstr = SvROK(ST(0)) ? "" : SvOK(ST(0)) ? "scalar " : "undef";
	    Perl_croak_nocontext("%s: Expected %s to be of type %s; got %s%" SVf " instead",
			"CWB::CL::cl_delete_corpus",
			"corpus", "CorpusPtr",
			refstr, ST(0)
		);
	}
;

	RETVAL = cl_delete_corpus(corpus);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_standard_registry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_standard_registry)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;
#line 220 "CL.xs"
    last_cl_error = CDA_OK;
#line 527 "CL.c"

	RETVAL = cl_standard_registry();
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_set_debug_level); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_set_debug_level)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "level");
    {
	int	level = (int)SvIV(ST(0))
;
#line 226 "CL.xs"
    last_cl_error = CDA_OK;
#line 549 "CL.c"

	cl_set_debug_level(level);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_CWB__CL_cl_set_optimize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_set_optimize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "state");
    {
	int	state = (int)SvIV(ST(0))
;
#line 232 "CL.xs"
    last_cl_error = CDA_OK;
#line 568 "CL.c"

	cl_set_optimize(state);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_CWB__CL_cl_set_memory_limit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_set_memory_limit)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "megabytes");
    {
	int	megabytes = (int)SvIV(ST(0))
;
#line 238 "CL.xs"
    last_cl_error = CDA_OK;
#line 587 "CL.c"

	cl_set_memory_limit(megabytes);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_CWB__CL_cl_make_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_make_set)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "s, split=\"\"");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	s = (char *)SvPV_nolen(ST(0))
;
	char *	split;
#line 245 "CL.xs"
    char *set;
    int split_mode;
#line 610 "CL.c"
	char *	RETVAL;
	dXSTARG;

	if (items < 2)
	    split = "";
	else {
	    split = (char *)SvPV_nolen(ST(1))
;
	}
#line 248 "CL.xs"
    last_cl_error = CDA_OK;
    if (split == NULL || (split[0] != '\0' && split[0] != 's'))
      croak("Usage:  $feature_set = CWB::CL::make_set($string [, 'split' | 's']);");
    split_mode = (split[0] == 's');
    set = cl_make_set(s, split_mode);
    if (set != NULL) {
      XPUSHs(sv_2mortal(newSVpv(set, 0)));  /* create Perl string (let Perl compute length) */
      free(set);  /* <set> was allocated by cl_make_set, so free it again */
    }   
    else {
      last_cl_error = cl_errno;
      if (strict_mode)
        croak_on_error(last_cl_error);
      XSRETURN_UNDEF;  /* else return undefined value */
    }
#line 636 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_set_intersection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_set_intersection)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s1, s2");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	s1 = (char *)SvPV_nolen(ST(0))
;
	char *	s2 = (char *)SvPV_nolen(ST(1))
;
#line 269 "CL.xs"
    static char result[CL_DYN_STRING_SIZE];  /* static buffer for results string */
    int ok;
#line 659 "CL.c"
	char *	RETVAL;
	dXSTARG;
#line 272 "CL.xs"
    last_cl_error = CDA_OK;
    ok = cl_set_intersection(result, s1, s2);
    if (ok) {
      XPUSHs(sv_2mortal(newSVpv(result, 0)));  /* create Perl string (let Perl compute length) */
    }
    else {
      last_cl_error = cl_errno;
      if (strict_mode)
        croak_on_error(last_cl_error);
      XSRETURN_UNDEF;  /* return undefined value */
    }
#line 674 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_set_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_set_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	char *	s = (char *)SvPV_nolen(ST(0))
;
#line 288 "CL.xs"
    int size;
#line 692 "CL.c"
	int	RETVAL;
	dXSTARG;
#line 290 "CL.xs"
    last_cl_error = CDA_OK;
    size = cl_set_size(s);
    if (size >= 0) {
      RETVAL = size;
    }
    else {
      last_cl_error = cl_errno;
      if (strict_mode)
        croak_on_error(last_cl_error);
      XSRETURN_UNDEF;  /* return undefined value */
    }
#line 707 "CL.c"
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_normalize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_normalize)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "corpus, flags, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Corpus*	corpus;
	int	flags = (int)SvIV(ST(1))
;
#line 309 "CL.xs"
    int i, id, size;
// NB 2017-07-02: commented out bits were amended for the new calling convention for cl_string_canonical().
// They can be deleted once we're sure it's working correctly.
    //char *s_orig, *s_norm;
    char *s_norm;
    SV *s_arg;
#line 734 "CL.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "CorpusPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    corpus = INT2PTR(Corpus *,tmp);
	}
	else {
		const char* refstr = SvROK(ST(0)) ? "" : SvOK(ST(0)) ? "scalar " : "undef";
	    Perl_croak_nocontext("%s: Expected %s to be of type %s; got %s%" SVf " instead",
			"CWB::CL::cl_normalize",
			"corpus", "CorpusPtr",
			refstr, ST(0)
		);
	}
;
#line 316 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 2;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        s_arg = ST(i+2);
        if (!SvOK(s_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef ID arguments return undef */
        }
        else {
          // s_orig = (char *) SvPV_nolen(s_arg);
          // s_norm = cl_malloc(2 * strlen(s_orig) + 1); /* need larger buffer if case-folding lengthens string */
          // strcpy(s_norm, s_orig);
          // cl_string_canonical(s_norm, cl_corpus_charset(corpus), flags);
          s_norm = cl_string_canonical((char *) SvPV_nolen(s_arg), cl_corpus_charset(corpus), flags, CL_STRING_CANONICAL_STRDUP);
          PUSHs(sv_2mortal(newSVpv(s_norm, 0)));
          cl_free(s_norm);
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 774 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_list_attributes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_list_attributes)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "corpus, type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Corpus*	corpus;
	int	type = (int)SvIV(ST(1))
;
#line 346 "CL.xs"
    cl_string_list names;
    int i, size;
#line 796 "CL.c"
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "CorpusPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    corpus = INT2PTR(Corpus *,tmp);
	}
	else {
		const char* refstr = SvROK(ST(0)) ? "" : SvOK(ST(0)) ? "scalar " : "undef";
	    Perl_croak_nocontext("%s: Expected %s to be of type %s; got %s%" SVf " instead",
			"CWB::CL::cl_list_attributes",
			"corpus", "CorpusPtr",
			refstr, ST(0)
		);
	}
;
#line 349 "CL.xs"
    last_cl_error = CDA_OK;
    names = cl_corpus_list_attributes(corpus, type);
    size = cl_string_list_size(names);
    /* never sets an error condition */
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        PUSHs(sv_2mortal(newSVpv(cl_string_list_get(names, i), 0)));
      }
    }
    cl_free_string_list(names);
#line 825 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_new_attribute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_new_attribute)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "corpus, attribute_name, type");
    {
	Corpus *	corpus;
	char *	attribute_name = (char *)SvPV_nolen(ST(1))
;
	int	type = (int)SvIV(ST(2))
;
	Attribute *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "CorpusPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    corpus = INT2PTR(Corpus *,tmp);
	}
	else {
		const char* refstr = SvROK(ST(0)) ? "" : SvOK(ST(0)) ? "scalar " : "undef";
	    Perl_croak_nocontext("%s: Expected %s to be of type %s; got %s%" SVf " instead",
			"CWB::CL::cl_new_attribute",
			"corpus", "CorpusPtr",
			refstr, ST(0)
		);
	}
;
#line 367 "CL.xs"
    last_cl_error = CDA_OK;
#line 861 "CL.c"

	RETVAL = cl_new_attribute(corpus, attribute_name, type);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, Nullch, (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_delete_attribute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_delete_attribute)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "attribute");
    {
	Attribute *	attribute;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    attribute = INT2PTR(Attribute *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"CWB::CL::cl_delete_attribute",
			"attribute")
;
#line 373 "CL.xs"
    last_cl_error = CDA_OK;
#line 897 "CL.c"

	RETVAL = cl_delete_attribute(attribute);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_max_cpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_max_cpos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "attribute");
    {
	PosAttrib	attribute;
	int	RETVAL;
	dXSTARG;

  if (sv_derived_from(ST(0), "CWB::CL::PosAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(PosAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::PosAttrib");
  }
;
#line 379 "CL.xs"
    last_cl_error = CDA_OK;
#line 928 "CL.c"

	RETVAL = cl_max_cpos(attribute);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_max_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_max_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "attribute");
    {
	PosAttrib	attribute;
	int	RETVAL;
	dXSTARG;

  if (sv_derived_from(ST(0), "CWB::CL::PosAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(PosAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::PosAttrib");
  }
;
#line 385 "CL.xs"
    last_cl_error = CDA_OK;
#line 959 "CL.c"

	RETVAL = cl_max_id(attribute);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_id2str); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_id2str)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	PosAttrib	attribute;
#line 391 "CL.xs"
    int i, id, size;
    char *s;
    SV *id_arg;
#line 983 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::PosAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(PosAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::PosAttrib");
  }
;
#line 395 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        id_arg = ST(i+1);
        if (!SvOK(id_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef ID arguments return undef */
        }
        else {
          id = (int) SvIV(id_arg);
          s = cl_id2str(attribute, id);
          if (s) {
            PUSHs(sv_2mortal(newSVpv(s, 0)));
          }
          else {
            last_cl_error = cl_errno;
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1020 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_str2id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_str2id)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	PosAttrib	attribute;
#line 426 "CL.xs"
    int i, id, size;
    char *s;
    SV *s_arg;
#line 1041 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::PosAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(PosAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::PosAttrib");
  }
;
#line 430 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        s_arg = ST(i+1);
        if (!SvOK(s_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef ID arguments return undef */
        }
        else {
          s = (char *) SvPV_nolen(s_arg);
          id = cl_str2id(attribute, s);
          if (id >= 0) {
            PUSHs(sv_2mortal(newSViv(id)));
          }
          else {
            if (cl_errno != CDA_ENOSTRING)
              last_cl_error = cl_errno; /* CDA_ENOSTRING indicates that string is not in lexicon (no error) */
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1079 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_id2strlen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_id2strlen)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	PosAttrib	attribute;
#line 462 "CL.xs"
    int i, id, len, size;
    SV *id_arg;
#line 1099 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::PosAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(PosAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::PosAttrib");
  }
;
#line 465 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        id_arg = ST(i+1);
        if (!SvOK(id_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef ID arguments return undef */
        }
        else {
          id = (int) SvIV(id_arg);
          len = cl_id2strlen(attribute, id);
          if (len >= 0) {
            PUSHs(sv_2mortal(newSViv(len)));
          }
          else {
            last_cl_error = cl_errno;
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1136 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_id2freq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_id2freq)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	PosAttrib	attribute;
#line 496 "CL.xs"
    int i, id, f, size;
    SV *id_arg;
#line 1156 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::PosAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(PosAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::PosAttrib");
  }
;
#line 499 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        id_arg = ST(i+1);
        if (!SvOK(id_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef ID arguments return undef */
        }
        else {
          id = (int) SvIV(id_arg);
          f = cl_id2freq(attribute, id);
          if (f >= 0) {
            PUSHs(sv_2mortal(newSViv(f)));
          }
          else {
            last_cl_error = cl_errno;
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1193 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_cpos2id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_cpos2id)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	PosAttrib	attribute;
#line 530 "CL.xs"
    int i, cpos, id, size;
    SV *cpos_arg;
#line 1213 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::PosAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(PosAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::PosAttrib");
  }
;
#line 533 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        cpos_arg = ST(i+1);
        if (!SvOK(cpos_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef cpos arguments return undef */
        }
        else {
          cpos = (int) SvIV(cpos_arg);
          id = cl_cpos2id(attribute, cpos);
          if (id >= 0) {
            PUSHs(sv_2mortal(newSViv(id)));
          }
          else {
            last_cl_error = cl_errno;
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1250 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_cpos2str); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_cpos2str)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	PosAttrib	attribute;
#line 564 "CL.xs"
    int i, cpos, size;
    char *s;
    SV *cpos_arg;
#line 1271 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::PosAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(PosAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::PosAttrib");
  }
;
#line 568 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        cpos_arg = ST(i+1);
        if (!SvOK(cpos_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef cpos arguments return undef */
        }
        else {
          cpos = (int) SvIV(cpos_arg);
          s = cl_cpos2str(attribute, cpos);
          if (s) {
            PUSHs(sv_2mortal(newSVpv(s, 0)));
          }
          else {
            last_cl_error = cl_errno;
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1308 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_regex2id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_regex2id)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "attribute, pattern, canonicalize");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	PosAttrib	attribute;
	char *	pattern = (char *)SvPV_nolen(ST(1))
;
	int	canonicalize = (int)SvIV(ST(2))
;
#line 601 "CL.xs"
    int number_of_matches = 0;
    int *idlist;
    int i;
#line 1333 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::PosAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(PosAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::PosAttrib");
  }
;
#line 605 "CL.xs"
    last_cl_error = CDA_OK;
    idlist = cl_regex2id(attribute, pattern, canonicalize, &number_of_matches);
    if (idlist != NULL) {
      EXTEND(sp, number_of_matches); /* push IDs on result stack */
      for (i=0; i < number_of_matches; i++)
        PUSHs(sv_2mortal(newSViv(idlist[i])));
      free(idlist);
    }
    else {
      if (strict_mode && cl_errno != CDA_OK)
        croak_on_error(cl_errno);
    }
    /* else return empty list */ 
#line 1357 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_idlist2freq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_idlist2freq)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    {
	PosAttrib	attribute;
#line 623 "CL.xs"
    int i, size, errors;
    int *list;
#line 1375 "CL.c"
	int	RETVAL;
	dXSTARG;

  if (sv_derived_from(ST(0), "CWB::CL::PosAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(PosAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::PosAttrib");
  }
;
#line 626 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      Newx(list, size, int); /* convert argument list to list of integer IDs */
      if (!list)
        croak("Can't allocate temporary array for %d integers", size);
      errors = 0;
      for (i = 0; i < size; i++) {
        if (SvOK(ST(i+1)))
          list[i] = (int) SvIV(ST(i+1));
        else
          errors++;
      }
      if (errors) {
        RETVAL = -1;
        last_cl_error = CWB_CL_INVALID_ARG;
      }
      else {
        RETVAL = cl_idlist2freq(attribute, list, size);
        if (RETVAL < 0)
          last_cl_error = cl_errno;
      }
      Safefree(list);
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
      if (RETVAL < 0)
        XSRETURN_UNDEF;
    }
    else {
      RETVAL = 0;
    }
#line 1419 "CL.c"
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_idlist2cpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_idlist2cpos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	PosAttrib	attribute;
#line 664 "CL.xs"
    int i, id, idlist_size, size, errors;
    int *idlist, *list;
#line 1440 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::PosAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(PosAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::PosAttrib");
  }
;
#line 667 "CL.xs"
    last_cl_error = CDA_OK;
    idlist_size = items - 1;
    if (idlist_size > 0) {
      Newx(idlist, idlist_size, int); /* convert argument list to list of integer IDs */
      if (!idlist)
        croak("Can't allocate temporary array of size %d in idlist2cpos() method\n", idlist_size);
      for (i = 0; i < idlist_size; i++) {
        if (SvOK(ST(i+1)))
          idlist[i] = (int) SvIV(ST(i+1));
        else {
          last_cl_error = CWB_CL_INVALID_ARG;
          break;
        }
      }
      if (last_cl_error != CDA_OK) {
        Safefree(idlist);
        if (strict_mode)
          croak_on_error(last_cl_error);
        /* else return empty list to indicate error condition (valid IDs would never return empty list) */
      }
      else {
        if (idlist_size > 1)
          list = cl_idlist2cpos(attribute, idlist, idlist_size, /* sorted */ 1, &size);
        else
          list = cl_id2cpos(attribute, idlist[0], &size); /* should be more efficient for single ID */
        Safefree(idlist);
        if (list) {
          EXTEND(sp, size);
          for (i=0; i < size; i++)
            PUSHs(sv_2mortal(newSViv(list[i])));
          free(list);
        }
        else {
          last_cl_error = cl_errno;
          if (strict_mode)
            croak_on_error(last_cl_error);
          /* else return empty list to indicate error condition */
        }
      }
    }
    /* else return empty list */
#line 1492 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_struc_values); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_struc_values)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "attribute");
    {
	Attribute *	attribute;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    attribute = INT2PTR(Attribute *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"CWB::CL::cl_struc_values",
			"attribute")
;
#line 714 "CL.xs"
    last_cl_error = CDA_OK;
#line 1521 "CL.c"

	RETVAL = cl_struc_values(attribute);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_max_struc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_max_struc)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "attribute");
    {
	Attribute *	attribute;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    attribute = INT2PTR(Attribute *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"CWB::CL::cl_max_struc",
			"attribute")
;
#line 720 "CL.xs"
    last_cl_error = CDA_OK;
#line 1553 "CL.c"

	RETVAL = cl_max_struc(attribute);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_cpos2struc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_cpos2struc)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	StrucAttrib	attribute;
#line 726 "CL.xs"
    int i, cpos, struc, size;
    SV *cpos_arg;
#line 1576 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::StrucAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(StrucAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::StrucAttrib");
  }
;
#line 729 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        cpos_arg = ST(i+1);
        if (!SvOK(cpos_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef cpos arguments return undef */
        }
        else {
          cpos = (int) SvIV(cpos_arg);
          struc = cl_cpos2struc(attribute, cpos);
          if (struc >= 0) {
            PUSHs(sv_2mortal(newSViv(struc)));
          }
          else {
            if (cl_errno != CDA_ESTRUC)
              last_cl_error = cl_errno; /* CDA_ESTRUC indicates that cpos is not in attribute region (no error) */
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1614 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_cpos2struc2str); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_cpos2struc2str)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	StrucAttrib	attribute;
#line 761 "CL.xs"
    int i, cpos, size;
    char *s;
    SV *cpos_arg;
#line 1635 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::StrucAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(StrucAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::StrucAttrib");
  }
;
#line 765 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        cpos_arg = ST(i+1);
        if (!SvOK(cpos_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef cpos arguments return undef */
        }
        else {
          cpos = (int) SvIV(cpos_arg);
          s = cl_cpos2struc2str(attribute, cpos);
          if (s) {
            PUSHs(sv_2mortal(newSVpv(s, 0)));
          }
          else {
            if (cl_errno != CDA_ESTRUC)
              last_cl_error = cl_errno; /* CDA_ESTRUC indicates that cpos is not in attribute region (no error) */
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1673 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_struc2str); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_struc2str)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	StrucAttrib	attribute;
#line 797 "CL.xs"
    int i, struc, size;
    char *s;
    SV *struc_arg;
#line 1694 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::StrucAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(StrucAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::StrucAttrib");
  }
;
#line 801 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        struc_arg = ST(i+1);
        if (!SvOK(struc_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef struc arguments return undef */
        }
        else {
          struc = (int) SvIV(struc_arg);
          s = cl_struc2str(attribute, struc);
          if (s) {
            PUSHs(sv_2mortal(newSVpv(s, 0)));
          }
          else {
            last_cl_error = cl_errno;
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1731 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_struc2cpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_struc2cpos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	StrucAttrib	attribute;
#line 832 "CL.xs"
    int i, struc, size, start, end;
    int *arguments;
    SV *struc_arg;
#line 1752 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::StrucAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(StrucAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::StrucAttrib");
  }
;
#line 836 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      /* Return values on stack overwrite function arguments, starting from ST(0).  This works in most
       * vectorised functions since we push one return value for each argument, i.e. we store the result
       * for ST(i+1) in ST(i).  Because cl_struc2cpos() returns two values for each argument, we have
       * to store all arguments in a locally allocated array first.
       */
      Newx(arguments, size, int); /* allocate temporary array to hold arguments (converted to C ints) */
      if (!arguments)
        croak("Can't allocate temporary array for %d integers", size);
      for (i = 0; i < size; i++) {
        struc_arg = ST(i+1);
        if (SvOK(struc_arg)) {
          arguments[i] = (int) SvIV(struc_arg);
        }
        else {
          last_cl_error = CWB_CL_INVALID_ARG;
          arguments[i] = -4242; /* so negative arguments will usually generate CDA_EIDXORNG */
        }
      }
      EXTEND(sp, 2 * size); /* now make sure stack has enough space for all return values */
      for (i = 0; i < size; i++) {
        struc = arguments[i];
        if (struc == -4242) {
          PUSHs(sv_newmortal()); /* invalid arguments return (undef, undef) pairs */
          PUSHs(sv_newmortal());
        }
        else {
          if (cl_struc2cpos(attribute, struc, &start, &end)) {
            PUSHs(sv_2mortal(newSViv(start))); /* push (start, end) pair on return stack */
            PUSHs(sv_2mortal(newSViv(end))); 
          }
          else {
            last_cl_error = cl_errno;
            PUSHs(sv_newmortal()); /* all errors are turned into (undef, undef) pairs */
            PUSHs(sv_newmortal());
          }
        }
      }
      Safefree(arguments);
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1808 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_cpos2struc2cpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_cpos2struc2cpos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	StrucAttrib	attribute;
#line 886 "CL.xs"
    int i, cpos, size, start, end;
    int *arguments;
    SV *cpos_arg;
#line 1829 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::StrucAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(StrucAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::StrucAttrib");
  }
;
#line 890 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      /* see above why we need to store arguments in a temporary array of C ints */
      Newx(arguments, size, int); /* allocate temporary array to hold arguments (converted to C ints) */
      if (!arguments)
        croak("Can't allocate temporary array for %d integers", size);
      for (i = 0; i < size; i++) {
        cpos_arg = ST(i+1);
        if (SvOK(cpos_arg)) {
          arguments[i] = (int) SvIV(cpos_arg);
        }
        else {
          last_cl_error = CWB_CL_INVALID_ARG;
          arguments[i] = -4242; /* so negative arguments will usually generate CDA_EIDXORNG */
        }
      }
      EXTEND(sp, 2 * size); /* now make sure stack has enough space for all return values */
      for (i = 0; i < size; i++) {
        cpos = arguments[i];
        if (cpos == -4242) {
          PUSHs(sv_newmortal()); /* invalid arguments return (undef, undef) pairs */
          PUSHs(sv_newmortal());
        }
        else {
          if (cl_cpos2struc2cpos(attribute, cpos, &start, &end)) {
            PUSHs(sv_2mortal(newSViv(start))); /* push (start, end) pair on return stack */
            PUSHs(sv_2mortal(newSViv(end))); 
          }
          else {
            if (cl_errno != CDA_ESTRUC)
              last_cl_error = cl_errno; /* CDA_ESTRUC indicates that cpos is not in attribute region (no error) */
            PUSHs(sv_newmortal()); /* all errors are turned into (undef, undef) pairs */
            PUSHs(sv_newmortal());
          }
        }
      }
      Safefree(arguments);
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1882 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_cpos2boundary); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_cpos2boundary)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	StrucAttrib	attribute;
#line 937 "CL.xs"
    int i, cpos, flags, size;
    SV *cpos_arg;
#line 1902 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::StrucAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(StrucAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::StrucAttrib");
  }
;
#line 940 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        cpos_arg = ST(i+1);
        if (!SvOK(cpos_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef cpos arguments return undef */
        }
        else {
          cpos = (int) SvIV(cpos_arg);
          flags = cl_cpos2boundary(attribute, cpos);
          if (flags >= 0) {
            PUSHs(sv_2mortal(newSViv(flags)));
          }
          else {
            last_cl_error = cl_errno; /* CDA_ESTRUC cannot occur here (simply returns flags=0) */
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 1939 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_cpos2is_boundary); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_cpos2is_boundary)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "attribute, test_flags, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	StrucAttrib	attribute;
	int	test_flags = (int)SvIV(ST(1))
;
#line 972 "CL.xs"
    int i, cpos, flags, is_boundary, size;
    SV *cpos_arg;
#line 1961 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::StrucAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(StrucAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::StrucAttrib");
  }
;
#line 975 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 2;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        cpos_arg = ST(i+2);
        if (!SvOK(cpos_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef cpos arguments return undef */
        }
        else {
          cpos = (int) SvIV(cpos_arg);
          flags = cl_cpos2boundary(attribute, cpos);
          if (flags >= 0) {
            if (test_flags) {
              is_boundary = ((flags & test_flags) == test_flags) ? 1 : 0;
            }
            else {
              is_boundary = (flags == 0) ? 1 : 0; /* special case: test whether token is outside region */
            }
            PUSHs(sv_2mortal(newSViv(is_boundary)));
          }
          else {
            last_cl_error = cl_errno; /* CDA_ESTRUC cannot occur here (simply returns flags=0) */
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 2004 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_has_extended_alignment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_has_extended_alignment)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "attribute");
    {
	AlignAttrib	attribute;
	int	RETVAL;
	dXSTARG;

  if (sv_derived_from(ST(0), "CWB::CL::AlignAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(AlignAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::AlignAttrib");
  }
;

	RETVAL = cl_has_extended_alignment(attribute);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_max_alg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_max_alg)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "attribute");
    {
	AlignAttrib	attribute;
	int	RETVAL;
	dXSTARG;

  if (sv_derived_from(ST(0), "CWB::CL::AlignAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(AlignAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::AlignAttrib");
  }
;

	RETVAL = cl_max_alg(attribute);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_CWB__CL_cl_cpos2alg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_cpos2alg)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	AlignAttrib	attribute;
#line 1020 "CL.xs"
    int i, cpos, alg, size;
    SV *cpos_arg;
#line 2080 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::AlignAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(AlignAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::AlignAttrib");
  }
;
#line 1023 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      EXTEND(sp, size);
      for (i = 0; i < size; i++) {
        cpos_arg = ST(i+1);
        if (!SvOK(cpos_arg)) {
          last_cl_error = CWB_CL_INVALID_ARG;
          PUSHs(sv_newmortal()); /* undef cpos arguments return undef */
        }
        else {
          cpos = (int) SvIV(cpos_arg);
          alg = cl_cpos2alg(attribute, cpos);
          if (alg >= 0) {
            PUSHs(sv_2mortal(newSViv(alg)));
          }
          else {
            if (cl_errno != CDA_EALIGN)
              last_cl_error = cl_errno; /* CDA_EALIGN indicates that cpos is not in alignment bead (no error) */
            PUSHs(sv_newmortal()); /* all errors are turned into undefs */
          }
        }
      }
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 2118 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_alg2cpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_alg2cpos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	AlignAttrib	attribute;
#line 1055 "CL.xs"
    int i, alg, size;
    int source_start, source_end, target_start, target_end;
    int *arguments;
    SV *alg_arg;
#line 2140 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::AlignAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(AlignAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::AlignAttrib");
  }
;
#line 1060 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      /* Return values on stack overwrite function arguments, starting from ST(0).  This works in most
       * vectorised functions since we push one return value for each argument, i.e. we store the result
       * for ST(i+1) in ST(i).  Because cl_alg2cpos() returns four values for each argument, we have
       * to store all results in a locally allocated array first.
       */
      Newx(arguments, size, int); /* allocate temporary array to hold arguments (converted to C ints) */
      if (!arguments)
        croak("Can't allocate temporary array for %d integers", size);
      for (i = 0; i < size; i++) {
        alg_arg = ST(i+1);
        if (SvOK(alg_arg)) {
          arguments[i] = (int) SvIV(alg_arg);
        }
        else {
          last_cl_error = CWB_CL_INVALID_ARG;
          arguments[i] = -4242; /* so negative arguments will usually generate CDA_EIDXORNG */
        }
      }
      EXTEND(sp, 4 * size); /* now make sure stack has enough space for all return values */
      for (i = 0; i < size; i++) {
        alg = arguments[i];
        if (alg == -4242) {
          PUSHs(sv_newmortal()); /* invalid arguments return (undef, undef, undef, undef) beads */
          PUSHs(sv_newmortal());
          PUSHs(sv_newmortal());
          PUSHs(sv_newmortal());
        }
        else {
          if (cl_alg2cpos(attribute, alg, &source_start, &source_end, &target_start, &target_end)) {
            PUSHs(sv_2mortal(newSViv(source_start))); /* push alignment bead on return stack */
            PUSHs(sv_2mortal(newSViv(source_end)));
            PUSHs(sv_2mortal(newSViv(target_start)));
            PUSHs(sv_2mortal(newSViv(target_end)));
          }   
          else {
            last_cl_error = cl_errno;
            PUSHs(sv_newmortal()); /* all errors are turned into (undef, undef, undef, undef) beads */
            PUSHs(sv_newmortal());
            PUSHs(sv_newmortal());
            PUSHs(sv_newmortal());
          }
        }
      }
      Safefree(arguments);
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 2202 "CL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_CWB__CL_cl_cpos2alg2cpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_CWB__CL_cl_cpos2alg2cpos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "attribute, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	AlignAttrib	attribute;
#line 1116 "CL.xs"
    int i, ok, cpos, alg, size;
    int source_start, source_end, target_start, target_end;
    int *arguments;
    SV *cpos_arg;
#line 2224 "CL.c"

  if (sv_derived_from(ST(0), "CWB::CL::AlignAttrib")) {
    IV tmp = SvIV((SV*)SvRV(ST(0)));
    attribute = INT2PTR(AlignAttrib,tmp);
  }
  else {
    Perl_croak(aTHX_ "attribute is not of type CWB::CL::AlignAttrib");
  }
;
#line 1121 "CL.xs"
    last_cl_error = CDA_OK;
    size = items - 1;
    if (size > 0) {
      /* Return values on stack overwrite function arguments, starting from ST(0).  This works in most
       * vectorised functions since we push one return value for each argument, i.e. we store the result
       * for ST(i+1) in ST(i).  Because cl_cpos2alg2cpos() returns four values for each argument, we have
       * to store all results in a locally allocated array first.
       */
      Newx(arguments, size, int); /* allocate temporary array to hold arguments (converted to C ints) */
      if (!arguments)
        croak("Can't allocate temporary array for %d integers", size);
      for (i = 0; i < size; i++) {
        cpos_arg = ST(i+1);
        if (SvOK(cpos_arg)) {
          arguments[i] = (int) SvIV(cpos_arg);
        }
        else {
          last_cl_error = CWB_CL_INVALID_ARG;
          arguments[i] = -4242; /* so negative arguments will usually trigger standard CL errors */
        }
      }
      EXTEND(sp, 4 * size); /* now make sure stack has enough space for all return values */
      for (i = 0; i < size; i++) {
        cpos = arguments[i];
        ok = 0;
        if (cpos != -4242) {
          alg = cl_cpos2alg(attribute, cpos);
          if ((alg >= 0) && 
              cl_alg2cpos(attribute, alg, &source_start, &source_end, &target_start, &target_end)) {
            PUSHs(sv_2mortal(newSViv(source_start))); /* push alignment bead on return stack */
            PUSHs(sv_2mortal(newSViv(source_end)));
            PUSHs(sv_2mortal(newSViv(target_start)));
            PUSHs(sv_2mortal(newSViv(target_end)));
            ok = 1;
          }   
          else {
            if (cl_errno != CDA_EALIGN)
              last_cl_error = cl_errno; /* CDA_EALIGN is not an error condition (no alignment found) */
          }
        }
        if (!ok) {
          PUSHs(sv_newmortal()); /* push (undef, undef, undef, undef) bead if no valid alignment was found */
          PUSHs(sv_newmortal());
          PUSHs(sv_newmortal());
          PUSHs(sv_newmortal());
        }
      }
      Safefree(arguments);
      if (strict_mode && last_cl_error != CDA_OK)
        croak_on_error(last_cl_error);
    }
    /* else return empty list */
#line 2287 "CL.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_CWB__CL); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_CWB__CL)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if PERL_VERSION_LE(5, 8, 999) /* PERL_VERSION_LT is 5.33+ */
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("CWB::CL::cwb_cl_error_message", XS_CWB__CL_cwb_cl_error_message, file, "$");
        (void)newXSproto_portable("CWB::CL::error_message", XS_CWB__CL_error_message, file, "");
        (void)newXSproto_portable("CWB::CL::set_strict_mode", XS_CWB__CL_set_strict_mode, file, "$");
        (void)newXSproto_portable("CWB::CL::get_strict_mode", XS_CWB__CL_get_strict_mode, file, "");
        (void)newXSproto_portable("CWB::CL::constant", XS_CWB__CL_constant, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_new_corpus", XS_CWB__CL_cl_new_corpus, file, "$$");
        (void)newXSproto_portable("CWB::CL::cl_corpus_charset_name", XS_CWB__CL_cl_corpus_charset_name, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_delete_corpus", XS_CWB__CL_cl_delete_corpus, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_standard_registry", XS_CWB__CL_cl_standard_registry, file, "");
        (void)newXSproto_portable("CWB::CL::cl_set_debug_level", XS_CWB__CL_cl_set_debug_level, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_set_optimize", XS_CWB__CL_cl_set_optimize, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_set_memory_limit", XS_CWB__CL_cl_set_memory_limit, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_make_set", XS_CWB__CL_cl_make_set, file, "$;$");
        (void)newXSproto_portable("CWB::CL::cl_set_intersection", XS_CWB__CL_cl_set_intersection, file, "$$");
        (void)newXSproto_portable("CWB::CL::cl_set_size", XS_CWB__CL_cl_set_size, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_normalize", XS_CWB__CL_cl_normalize, file, "$$;@");
        (void)newXSproto_portable("CWB::CL::cl_list_attributes", XS_CWB__CL_cl_list_attributes, file, "$$");
        (void)newXSproto_portable("CWB::CL::cl_new_attribute", XS_CWB__CL_cl_new_attribute, file, "$$$");
        (void)newXSproto_portable("CWB::CL::cl_delete_attribute", XS_CWB__CL_cl_delete_attribute, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_max_cpos", XS_CWB__CL_cl_max_cpos, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_max_id", XS_CWB__CL_cl_max_id, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_id2str", XS_CWB__CL_cl_id2str, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_str2id", XS_CWB__CL_cl_str2id, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_id2strlen", XS_CWB__CL_cl_id2strlen, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_id2freq", XS_CWB__CL_cl_id2freq, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_cpos2id", XS_CWB__CL_cl_cpos2id, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_cpos2str", XS_CWB__CL_cl_cpos2str, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_regex2id", XS_CWB__CL_cl_regex2id, file, "$$$");
        (void)newXSproto_portable("CWB::CL::cl_idlist2freq", XS_CWB__CL_cl_idlist2freq, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_idlist2cpos", XS_CWB__CL_cl_idlist2cpos, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_struc_values", XS_CWB__CL_cl_struc_values, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_max_struc", XS_CWB__CL_cl_max_struc, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_cpos2struc", XS_CWB__CL_cl_cpos2struc, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_cpos2struc2str", XS_CWB__CL_cl_cpos2struc2str, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_struc2str", XS_CWB__CL_cl_struc2str, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_struc2cpos", XS_CWB__CL_cl_struc2cpos, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_cpos2struc2cpos", XS_CWB__CL_cl_cpos2struc2cpos, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_cpos2boundary", XS_CWB__CL_cl_cpos2boundary, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_cpos2is_boundary", XS_CWB__CL_cl_cpos2is_boundary, file, "$$;@");
        (void)newXSproto_portable("CWB::CL::cl_has_extended_alignment", XS_CWB__CL_cl_has_extended_alignment, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_max_alg", XS_CWB__CL_cl_max_alg, file, "$");
        (void)newXSproto_portable("CWB::CL::cl_cpos2alg", XS_CWB__CL_cl_cpos2alg, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_alg2cpos", XS_CWB__CL_cl_alg2cpos, file, "$;@");
        (void)newXSproto_portable("CWB::CL::cl_cpos2alg2cpos", XS_CWB__CL_cl_cpos2alg2cpos, file, "$;@");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

