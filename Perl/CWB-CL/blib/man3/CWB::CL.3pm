.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "CWB::CL 3"
.TH CWB::CL 3 "2022-05-07" "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CWB::CL \- Perl interface to the low\-level C API of the IMS Open Corpus Workbench
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use CWB::CL;
\&
\&  print "Registry path = ", $CWB::CL::Registry, "\en";
\&  $CWB::CL::Registry .= ":/home/my_registry";    # add your own registry directory
\&
\&  # "strict" mode aborts if any error occurs (convenient in one\-off scripts)
\&  CWB::CL::strict(1);                            # or simply load CWB::CL::Strict module
\&  CWB::CL::set_debug_level(\*(Aqsome\*(Aq);              # \*(Aqsome\*(Aq, \*(Aqall\*(Aq or \*(Aqnone\*(Aq (default)
\&  CWB::CL::set_optimizer(1);                     # enable experimental optimizations in CL (if any)
\&
\&  CWB::CL::error_message();                      # error message for last method call (or "")
\&
\&  # CWB::CL::Corpus objects
\&  $corpus = new CWB::CL::Corpus "EUROPARL\-EN";   # name of corpus can be upper or lower case
\&  die "Error: can\*(Aqt access corpus EUROPARL\-EN"   # all error conditions return undef
\&    unless defined $corpus;                      #   (checks are not needed in "strict" mode)
\&  undef $corpus;                                 # currently a no\-op (CL implementation is buggy)
\&
\&  $charset = $corpus\->charset;                   # declared character encoding of the corpus
\&  $folded = $corpus\->normalize("cd", $string);   # CWB\-compatible case\- and diacritic\-folding
\&                                                 # (use "n" for UTF\-8 strings from external sources)
\&
\&  # CWB::CL::PosAttrib objects (positional attributes)
\&  $lemma = $corpus\->attribute("lemma", \*(Aqp\*(Aq);     # returns CWB::CL::PosAttrib object
\&  $corpus_length = $lemma\->max_cpos;             # valid cpos values are 0 .. $corpus_length\-1
\&  $lexicon_size = $lemma\->max_id;                # valid id values are 0 .. $lexicon_size\-1
\&
\&  $id  = $lemma\->str2id($string);                # lookup lexicon ID of type $string
\&  @idlist = $lemma\->str2id(@strlist);            # (all scalar functions map to lists in list context)
\&  $str = $lemma\->id2str($id);                    # type with lexicon ID $id
\&  $len = $lemma\->id2strlen($id);                 # string length of type with ID $id
\&  $f   = $lemma\->id2freq($id);                   # corpus frequency of type with ID $id
\&  $id  = $lemma\->cpos2id($cpos);                 # lexicon ID of value at corpus position $cpos
\&  $str = $lemma\->cpos2str($cpos);                # type annotated at corpus position $cpos
\&
\&  @idlist = $lemma\->regex2id($re);               # find all lexicon IDs matching regular expression
\&  @idlist = $lemma\->regex2id($re, \*(Aqcd\*(Aq);         #   with optional flags \*(Aqn\*(Aq, \*(Aqc\*(Aq, \*(Aqd\*(Aq
\&  @cpos = $lemma\->idlist2cpos(@idlist);          # occurrences of all types in @idlist
\&  $total_freq = $lemma\->idlist2freq(@idlist);    # total corpus frequency of @idlist (w/o decoding index)
\&
\&
\&  # CWB::CL::StrucAttrib objects (structural attributes)
\&  $chapter = $corpus\->attribute("chapter", \*(Aqs\*(Aq); # returns CWB::CL::StrucAttrib object
\&  $number_of_regions = $chapter\->max_struc;      # valid region numbers are 0 .. $number_of_regions\-1
\&  $has_values = $chapter\->struc_values;          # are regions annotated with strings?
\&
\&  $struc = $chapter\->cpos2struc($cpos);          # number of <chapter> region containing $cpos (or undef)
\&  ($start, $end) = $chapter\->struc2cpos($struc); # start and end of region number $struc
\&  @pairs = $chapter\->struc2cpos(@struc_list);    # returns flat list ($s1, $e1, $s2, $e2, ...)
\&  $str  = $chapter\->struc2str($struc);           # annotation string for region number $struc (or undef)
\&  $str  = $chapter\->cpos2str($cpos);             # annotation string for region around $cpos (or undef)
\&
\&  ($s, $e) = $chapter\->cpos2struc2cpos($cpos);   # start/end of <chapter> region around $cpos
\&  @pairs = $chapter\->cpos2struc2cpos(@cpos_list);# returns 2 * N values for N arguments (cf. above)
\&
\&  # check whether corpus position is at boundary (l, r, lr) or inside/outside (i/o) of region
\&  if ($chapter\->cpos2boundary($cpos) & $CWB::CL::Boundary{\*(Aql\*(Aq}) { ... }
\&  if ($chapter\->cpos2is_boundary(\*(Aql\*(Aq, $cpos)) { ... }
\&
\&
\&  # CWB::CL::AlignAttrib objects (alignment attributes)
\&  $ger = $corpus\->attribute("europarl\-de", \*(Aqa\*(Aq); # returns CWB::CL::AlignAttrib object
\&  $nr_of_beads = $ger\->max_alg;                  # alignment bead numbers are 0 .. $nr_of_beads\-1
\&  if ($ger\->has_extended_alignment) { ... }      # extended alignment allows gaps & crossing alignments
\&  
\&  $bead = $ger\->cpos2alg($cpos);                 # alignment bead containing $cpos (or undef)
\&  ($src_start, $src_end, $tgt_start, $tgt_end)   # aligned spans in source and target corpus
\&      = $ger\->alg2cpos($bead);
\&  @quads = $ger\->alg2cpos(@bead_list);           # flat list of quadruplets (one for each alignment bead)
\&  @quads = $ger\->cpos2alg2cpos(@cpos_list);      # find alignments (source/target spans) for corpus position(s)
\&
\&
\&  # Feature sets (can be used as values of positional and structural attributes)
\&  $np_f = $corpus\->attribute("np_feat", \*(Aqs\*(Aq);    # p\- and s\-attributes can store feature sets
\&  $fs_string = $np_f\->cpos2str($cpos);           # feature sets are encoded as strings
\&  $fs  = CWB::CL::set2hash($fs_string);          # expand feature set into hash (returns hashref)
\&  if (exists $fs\->{"paren"}) { ... }
\&  $fs1 = CWB::CL::make_set("|proper|nogen|");    # validate feature set (reorders values)
\&  $fs2 = CWB::CL::make_set("paren nogen proper", \*(Aqsplit\*(Aq); # or construct from blank\-delimited string
\&  $fs3 = CWB::CL::make_set($fs);                           # or from hash reference
\&  $fs  = CWB::CL::set_intersection($fs1, $fs2);  # intersection of feature set values
\&  $n   = CWB::CL::set_size($fs);                 # size of feature set
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an interface to the low-level \fBCorpus Library\fR for accessing CWB-indexed corpora. It follows the Corpus Library \s-1API\s0 closely, except for an object-oriented design with simplified method names and the addition of a few convenience methods.
.PP
All scalar access methods \- usually named \f(CW\*(C`xxx2yyy\*(C'\fR \- are vectorized: they automatically map to multiple input arguments and return a flat list of results.  Vectorization is implemented in C code, ensuring high performance.
.PP
All errors and out-of-bounds accesses are turned into undefined values (\fBundef\fR) unless \fBstrict mode\fR is enabled (e.g. with \f(CW\*(C`use CWB::CL::strict;\*(C'\fR).  If an item is not found \- e.g. a given type string is not in the lexicon of a p\-attribute, or a given corpus position is not within an s\-attribute region \- the method will also return \fBundef\fR.  Vectorized method calls may return a mixture of defined and undefined values.
.SH "CWB3 DATA MODEL"
.IX Header "CWB3 DATA MODEL"
\&\s-1CWB\s0 is based on a \fBtabular data\fR model, which represents a corpus as a sequence of tokens annotated with one or more string values in the form of an annotation table.
.PP
.Vb 12
\&      word    pos     lemma
\&      \-\-\-\-    \-\-\-     \-\-\-\-\-
\&  0   Dogs    NNS     dog
\&  1   like    VBP     like
\&  2   cats    NNS     cat
\&  3   .       SENT    .
\&  4   Cats    NNS     cat
\&  5   do      VBP     do
\&  6   n\*(Aqt     RB      not
\&  7   like    VB      like
\&  8   dogs    NNS     dog
\&  9   .       SENT    .
.Ve
.PP
Tokens are identified by their row number starting from 0, which is known as \fBcorpus position\fR (or \fBcpos\fR) for short.  The first column of the table, always labelled \fIword\fR, contains the surface forms of the tokens.  Further columns, which can be labelled with arbitrary \s-1ASCII\s0 identifiers, contain token-level annotations (in this case part-of-speech tags (\fIpos\fR) and lemmatization (\fIlemma\fR)).  Each table column forms a separate \fBpositional attribute\fR (or \fBp\-attribute\fR for short) in the \s-1CWB\s0 data model.  The token sequence itself is thus a regular p\-attribute with the special name \fIword\fR.
.PP
For the sake of efficiency and data compression, p\-attributes use a numeric indexing scheme based on a \fBlexicon\fR of all distinct annotation strings (\fBtypes\fR), which are assigned numeric \fB\s-1ID\s0\fRs starting from 0.  Each p\-attribute has its own lexicon, e.g. for \fIpos\fR with the types 0 = \s-1NNS, 1\s0 = \s-1VBP, 2\s0 = \s-1SENT, 3\s0 = \s-1RB\s0 and 4 = \s-1VB.\s0
.PP
\&\fB\s-1CWB::CL\s0\fR provides methods for mapping between corpus positions, lexicon IDs, type strings and type frequencies.
.PP
\&\s-1XML\s0 tags in \s-1CWB\s0 input files are stored as \fBstructural attributes\fR (or \fBs\-attributes\fR for short).  Each s\-attribute indexes a sequence of non-overlapping, non-nested regions corresponding to \s-1XML\s0 elements of the same name.  Consider this example:
.PP
.Vb 10
\&      <text title="All about dogs">
\&      <s n="1" words="3">
\&  0   Dogs    NNS     dog
\&  1   like    VBP     like
\&  2   cats    NNS     cat
\&  3   .       SENT    .
\&      </s>
\&      <s n="2" words="4">
\&  4   Cats    NNS     cat
\&  5   do      VBP     do
\&  6   n\*(Aqt     RB      not
\&  7   like    VB      like
\&  8   dogs    NNS     dog
\&  9   .       SENT    .
\&      </s>
\&      </text>
.Ve
.PP
Note that there are no separate corpus positions assigned to \s-1XML\s0 tags, which are positioned at boundaries between tokens.  The single \f(CW\*(C`<text>\*(C'\fR region is stored in an s\-attribute named \fItext\fR; the two \f(CW\*(C`<s>\*(C'\fR regions are stored in an s\-attributed named \fIs\fR.  Attribute-value pairs in \s-1XML\s0 start tags are converted to additional s\-attributes \fItext_title\fR, \fIs_n\fR and \fIs_words\fR.
.PP
Each s\-attribute region is represented by its start and end corpus position, e.g. (0, 3) for the first sentence and (4, 9) for the second sentence above.  The regions are numbered starting from 0; such region numbers are referred to as \f(CW\*(C`struc\*(C'\fR in method names.
.PP
If an s\-attribute represents annotation in \s-1XML\s0 start tags, its regions are annotated with string values (e.g. \*(L"3\*(R" and \*(L"4\*(R" for the two regions of s\-attribute \fIs_words\fR).  These strings are not indexed with the help of a lexicon, so access is much less efficient than for p\-attributes.
.PP
\&\fB\s-1CWB::CL\s0\fR provides methods to access the span and annotation of an s\-attribute region, to find the region number containing a given cpos and to test for the start or end of a region.
.PP
Sentence-level alignment between two different corpora is represented by \fBalignment attributes\fR (or \fBa\-attributes\fR for short).  The name of an alignment attribute corresponds to the \s-1CWB ID\s0 of the target corpus in lowercase; as a consequence, there can only be a single alignment for each pair of source and target corpus.  An a\-attribute indexes a sequence of \fBalignment beads\fR that connect a token span \f(CW\*(C`(src_start, src_end)\*(C'\fR in the source corpus with a span \f(CW\*(C`(tgt_start, tgt_end)\*(C'\fR in the target corpus.  These spans need not correspond to sentence regions.
.PP
Alignment beads are numbered starting from 0, in the order of their positions in the source corpus.  Both the source spans and the target spans must be non-overlapping and must not be nested.  Most alignment attributes will use this new-style \*(L"extended\*(R" format. Only some legacy corpora may contain old-style a\-attributes, which do not allow for crossing alignments or gaps between beads.
.PP
\&\fB\s-1CWB::CL\s0\fR provides methods to access the source and target spans of an alignment bead, and to find the bead number containing a given corpus position in the source corpus.
.SH "Global Configuration and Utilities"
.IX Header "Global Configuration and Utilities"
.ie n .IP "$CWB::CL::Registry" 4
.el .IP "\f(CW$CWB::CL::Registry\fR" 4
.IX Item "$CWB::CL::Registry"
Path to \s-1CWB\s0 registry directory, or multiple paths separated by colons (\f(CW\*(C`:\*(C'\fR).  This variable can be modified to change the registry in which corpora will be searched.  It does not affect \fBCWB::CL::Corpus\fR objects that have already been created.
.ie n .IP "$error = \fBCWB::CL::error_message()\fR;" 4
.el .IP "\f(CW$error\fR = \fBCWB::CL::error_message()\fR;" 4
.IX Item "$error = CWB::CL::error_message();"
Human-readable error message for an error encountered during the last method call. If the call was successful, an empty string is returned.
.IP "\fBCWB::CL::strict\fR\|(1);" 4
.IX Item "CWB::CL::strict;"
Enable \fBstrict mode\fR, so that the Perl script will immediately be terminated if there is any error or invalid access (instead of returning \fBundef\fR values).  Strict mode can also be enabled by importing the module as \f(CW\*(C`use CWB::CL::Strict;\*(C'\fR).
.Sp
Strict mode is a convenience feature for one-off scripts and command-line tools run by end users.  Production software should keep strict mode disabled and check all return values instead.
.IP "CWB::CL::set_debug_level(\fI\f(CI$lvl\fI\fR)" 4
.IX Item "CWB::CL::set_debug_level($lvl)"
Set the amount of debugging information printed on \f(CW\*(C`stderr\*(C'\fR by the Corpus Library.  Admissible values for \fI\f(CI$lvl\fI\fR are 0 or \f(CW\*(C`none\*(C'\fR (no output), 1 or \f(CW\*(C`some\*(C'\fR (some messages), 2 or \f(CW\*(C`all\*(C'\fR (all messages).
.IP "\fBCWB::CL::set_optimize\fR\|(1);" 4
.IX Item "CWB::CL::set_optimize;"
Enable experimental optimizations in the Corpus Library.  In the \s-1CWB 3.4\s0 beta series leading up to \s-1CWB 3.5,\s0 the only optimization provides a minor speed-up for certain simple regular expressions.
.Sp
Stable releases do not contain any experimental optimizations, so this option has no effect.
.SS "Feature Sets"
.IX Subsection "Feature Sets"
Feature set annotation uses a special string notation for sets of feature values.  The individual values in the set are sorted in \s-1CWB\s0 order, separated by pipe characters (\f(CW\*(C`|\*(C'\fR) and enclosed in pipe characters.  For example, the set {\fIsmall\fR, \fImedium\fR, \fIbig\fR} is represented by the string
.PP
.Vb 1
\&  |big|medium|small|
.Ve
.PP
and the empty set by
.PP
.Vb 1
\&  |
.Ve
.PP
Keep in mind that there must not be any duplicate values in a set.  Features sets can be used as annotation values for p\-attributes and s\-attributes.  The Corpus Query Processor (\s-1CQP\s0) provides special operators \f(CW\*(C`contains\*(C'\fR and \f(CW\*(C`matches\*(C'\fR for searching feature sets with regular expressions, as well as functions for computing set size (\f(CW\*(C`ambiguity()\*(C'\fR) and set intersection (\f(CW\*(C`unify()\*(C'\fR).
.PP
\&\fB\s-1CWB::CL\s0\fR offers some convenience functions for creating and manipulating feature sets.  These functions are implemented in C code for efficiency.
.IP "\fI\f(CI$fs\fI\fR = CWB::CL::make_set(\fI\f(CI$values\fI\fR [, 's']);" 4
.IX Item "$fs = CWB::CL::make_set($values [, 's']);"
Create a feature set from \fI\f(CI$values\fI\fR, which is either a string in feature set notation or a hashref.  In the first case, correct notation is checked and the values are sorted if necessary (\s-1CWB\s0 v3.4.29 and newer are more lenient and will automatically add the surrounding delimiters).  In the second case, a feature set is constructed from the keys of the hash \fI%$values\fR.
.Sp
If a second argument \f(CW\*(C`s\*(C'\fR (or \f(CW\*(C`split\*(C'\fR) is passed, the string \fI\f(CI$value\fI\fR is split on whitespace.
.IP "\fI\f(CI$fs\fI\fR = CWB::CL::set_intersection(\fI\f(CI$fs1\fI\fR, \fI\f(CI$fs2\fI\fR);" 4
.IX Item "$fs = CWB::CL::set_intersection($fs1, $fs2);"
Compute the intersection of two feature sets \fI\f(CI$fs1\fI\fR and \fI\f(CI$fs2\fI\fR, i.e. a feature set containing all shared values.  This function only works correctly if both arguments are sorted and use valid feature set notation.  It correspond to the \f(CW\*(C`unify()\*(C'\fR function in \s-1CQP.\s0
.IP "\fI\f(CI$n\fI\fR = CWB::CL::set_size(\fI\f(CI$fs\fI\fR);" 4
.IX Item "$n = CWB::CL::set_size($fs);"
Return the cardinality of a feature set \fI\f(CI$fs\fI\fR, i.e. the number of elements.  This function only works correctly if \fI\f(CI$fs\fI\fR uses valid feature set notation.  It corresponds to the \f(CW\*(C`ambiguity()\*(C'\fR function in \s-1CQP.\s0
.IP "\fI\f(CI$values\fI\fR = CWB::CL::set2hash(\fI\f(CI$fs\fI\fR);" 4
.IX Item "$values = CWB::CL::set2hash($fs);"
Expand feature set \fI\f(CI$fs\fI\fR in \s-1CWB\s0 notation into a hash, with elements as keys and values set to 1.  Returns a hashref \fI\f(CI$values\fI\fR.
.SH "Corpora (CWB::CL::Corpus)"
.IX Header "Corpora (CWB::CL::Corpus)"
Each \s-1CWB\s0 corpus is represented by a \fBCWB::CL::Corpus\fR object.  The object constructor locates a suitable registry file and accesses the corpus.  Attribute handles are then obtained with the \fBattribute\fR method.
.ie n .IP "\fI\f(CI$corpus\fI\fR = new CWB::CL::Corpus $ID;" 4
.el .IP "\fI\f(CI$corpus\fI\fR = new CWB::CL::Corpus \f(CW$ID\fR;" 4
.IX Item "$corpus = new CWB::CL::Corpus $ID;"
Access corpus with \s-1CWB ID\s0 \fI\f(CI$ID\fI\fR, usually specified in uppercase letters.  The constructor looks for a registry file in the path(s) specified by \fI\f(CI$CWB::CL::Registry\fI\fR.  Returns a corpus handle, i.e. an object of class \fBCWB::CL::Corpus\fR, or \fBundef\fR if the corpus cannot be found (unless strict mode is enabled).
.IP "\fI\f(CI$att\fI\fR = \fI\f(CI$corpus\fI\fR\->attribute(\fI\f(CI$name\fI\fR, \fI\f(CI$type\fI\fR);" 4
.IX Item "$att = $corpus->attribute($name, $type);"
Obtain attribute handle for the attribute with name \fI\f(CI$name\fI\fR and type \fI\f(CI$type\fI\fR (\f(CW\*(C`p\*(C'\fR = positional, \f(CW\*(C`s\*(C'\fR = structural, \f(CW\*(C`a\*(C'\fR = alignment).  Note that legacy corpora may contain attributes of different types with the same name, even though this has been deprecated.  Returns \fBundef\fR if the attribute does not exist (unless strict mode is enabled).
.Sp
Classes for handles of different attribute types and their access methods are described below.
.IP "\fI\f(CI@names\fI\fR = \fI\f(CI$corpus\fI\fR\->list_attributes([\fI\f(CI$type\fI\fR]);" 4
.IX Item "@names = $corpus->list_attributes([$type]);"
Returns the names of all attributes defined for \fI\f(CI$corpus\fI\fR.  Attribute names will be listed in the same order as in the registry file.
.Sp
If \fI\f(CI$type\fI\fR is specified, only list attributes of the selected type (\f(CW\*(C`p\*(C'\fR, \f(CW\*(C`s\*(C'\fR or \f(CW\*(C`a\*(C'\fR).
.IP "\fI\f(CI$folded\fI\fR = \fI\f(CI$corpus\fI\fR\->normalize(\fI\f(CI$flags\fI\fR, \fI\f(CI$string\fI\fR);" 4
.IX Item "$folded = $corpus->normalize($flags, $string);"
.PD 0
.IP "\fI\f(CI@folded\fI\fR = \fI\f(CI$corpus\fI\fR\->normalize(\fI\f(CI$flags\fI\fR, \fI\f(CI@strings\fI\fR);" 4
.IX Item "@folded = $corpus->normalize($flags, @strings);"
.PD
Normalize one or more strings according to \fI\f(CI$flags\fI\fR, which is any combination of the flags below in the specified order.
.Sp
.Vb 3
\&  n   normalize UTF\-8 strings to CWB canonical form (NFC)
\&  c   fold strings to lowercase
\&  d   remove all diacritics (combining marks)
.Ve
.Sp
Admissible values for \fI\f(CI$type\fI\fR are thus \f(CW\*(C`c\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`cd\*(C'\fR, \f(CW\*(C`n\*(C'\fR, \f(CW\*(C`nc\*(C'\fR, \f(CW\*(C`nd\*(C'\fR and \f(CW\*(C`ncd\*(C'\fR.  Note that \fBnormalize\fR is a method because it depends on the character encoding of the corpus.
.IP "\fI\f(CI$charset\fI\fR = \fI\f(CI$corpus\fI\fR\->charset;" 4
.IX Item "$charset = $corpus->charset;"
Character encoding of \fI\f(CI$corpus\fI\fR (using \s-1CWB\s0 notation, same as in registry files). Typical values are \f(CW\*(C`utf8\*(C'\fR, \f(CW\*(C`latin1\*(C'\fR and \f(CW\*(C`ascii\*(C'\fR.
.SH "Positional Attributes (CWB::CL::PosAttrib)"
.IX Header "Positional Attributes (CWB::CL::PosAttrib)"
Handles for p\-attributes are represented by objects of class \fBCWB::CL::PosAttrib\fR.  They should never be constructed directly, but rather obtained from the \fBattribute\fR method of a corpus handle.
.IP "\fI\f(CI$N\fI\fR = \fI\f(CI$att\fI\fR\->max_cpos;" 4
.IX Item "$N = $att->max_cpos;"
Returns the number of tokens in the corpus (which is technically a property of each p\-attribute).  Note that the name of the function is misleading: valid corpus positions range from 0 to \fI\f(CI$N\fI\fR\-1.
.IP "\fI\f(CI$V\fI\fR = \fI\f(CI$att\fI\fR\->max_id;" 4
.IX Item "$V = $att->max_id;"
Returns the number of distinct types in the lexicon of the p\-attribute.  Note that the name of the function is misleading: valid type IDs range from 0 to \fI\f(CI$V\fI\fR\-1.
.IP "\fI\f(CI$type\fI\fR = \fI\f(CI$att\fI\fR\->id2str(\fI\f(CI$id\fI\fR);" 4
.IX Item "$type = $att->id2str($id);"
.PD 0
.IP "\fI\f(CI@types\fI\fR = \fI\f(CI$att\fI\fR\->id2str(\fI\f(CI@ids\fI\fR);" 4
.IX Item "@types = $att->id2str(@ids);"
.PD
Find type (string) corresponding to numerical lexicon \fI\f(CI$id\fI\fR.  Returns \fBundef\fR for lexicon IDs that are out of range and all other errors.
.IP "\fI\f(CI$len\fI\fR = \fI\f(CI$att\fI\fR\->id2strlen(\fI\f(CI$id\fI\fR);" 4
.IX Item "$len = $att->id2strlen($id);"
.PD 0
.IP "\fI\f(CI@lens\fI\fR = \fI\f(CI$att\fI\fR\->id2strlen(\fI\f(CI@ids\fI\fR);" 4
.IX Item "@lens = $att->id2strlen(@ids);"
.PD
Returns length of type string corresponding to numerical lexicon \fI\f(CI$id\fI\fR, measured in bytes.  This method is provided for consistency with the Corpus Library \s-1API,\s0 where it determines string length efficiently without having to scan the string.  Its Perl complement has no speed benefit and the \fBid2str\fR method should be preferred.
.IP "\fI\f(CI$f\fI\fR = \fI\f(CI$att\fI\fR\->id2freq(\fI\f(CI$id\fI\fR);" 4
.IX Item "$f = $att->id2freq($id);"
.PD 0
.IP "\fI\f(CI@fs\fI\fR = \fI\f(CI$att\fI\fR\->id2freq(\fI\f(CI@ids\fI\fR);" 4
.IX Item "@fs = $att->id2freq(@ids);"
.PD
Returns corpus frequency of the type with numerical lexicon \s-1ID\s0 \fI\f(CI$id\fI\fR (\fBundef\fR for lexicon IDs that are out of range and all other errors).
.IP "\fI\f(CI$id\fI\fR = \fI\f(CI$att\fI\fR\->str2id(\fI\f(CI$type\fI\fR);" 4
.IX Item "$id = $att->str2id($type);"
.PD 0
.IP "\fI\f(CI@ids\fI\fR = \fI\f(CI$att\fI\fR\->str2id(\fI\f(CI@types\fI\fR);" 4
.IX Item "@ids = $att->str2id(@types);"
.PD
Search \fI\f(CI$type\fI\fR (string) in lexicon and return its \s-1ID\s0 if successful.  Returns \fBundef\fR for all types not found in the lexicon and for all errors.  An out-of-vocabulary \fI\f(CI$type\fI\fR is not an error and will return \fBundef\fR even in strict mode.
.IP "\fI\f(CI$id\fI\fR = \fI\f(CI$att\fI\fR\->cpos2id(\fI\f(CI$cpos\fI\fR);" 4
.IX Item "$id = $att->cpos2id($cpos);"
.PD 0
.IP "\fI\f(CI@ids\fI\fR = \fI\f(CI$att\fI\fR\->cpos2id(\fI\f(CI@cpos\fI\fR);" 4
.IX Item "@ids = $att->cpos2id(@cpos);"
.PD
Returns the lexicon \s-1ID\s0 of the annotation at corpus position \fI\f(CI$cpos\fI\fR (\fBundef\fR if \fI\f(CI$cpos\fI\fR is out of range and all other errors).
.IP "\fI\f(CI$type\fI\fR = \fI\f(CI$att\fI\fR\->cpos2str(\fI\f(CI$cpos\fI\fR);" 4
.IX Item "$type = $att->cpos2str($cpos);"
.PD 0
.IP "\fI\f(CI@types\fI\fR = \fI\f(CI$att\fI\fR\->cpos2str(\fI\f(CI@cpos\fI\fR);" 4
.IX Item "@types = $att->cpos2str(@cpos);"
.PD
Returns the type string annotated at corpus position \fI\f(CI$cpos\fI\fR (\fBundef\fR if \fI\f(CI$cpos\fI\fR is out of range and all other errors).
.Sp
This method is equivalent to
.Sp
.Vb 1
\&  @types = $att\->id2str($att\->cpos2id(@cpos));
.Ve
.Sp
but faster and it does not have to allocate memory for the intermediate result.  It is very convenient for displaying parts of the corpus text.
.IP "\fI\f(CI@ids\fI\fR = \fI\f(CI$att\fI\fR\->regex2id(\fI\f(CI$rx\fI\fR[, \fI\f(CI$flags\fI\fR]);" 4
.IX Item "@ids = $att->regex2id($rx[, $flags]);"
Scan lexicon of \fI\f(CI$att\fI\fR with regular expression \fI\f(CI$rx\fI\fR and return the lexicon IDs of all matching types. \fI\f(CI$rx\fI\fR always has to match the full type string; start and end anchors are not required.  The Corpus Library uses \s-1PCRE\s0 regular expressions <http://www.pcre.org/current/doc/html/>, so the two lines below are mostly equivalent:
.Sp
.Vb 1
\&  @types = $att\->id2str($att\->regex2id($rx));
\&
\&  @types = grep { /^($rx)$/ } $att\->id2str(0 .. ($att\->max_id \- 1));
.Ve
.Sp
However, there will be differences in some corner cases, e.g. case-insensitive matching for non-ASCII characters.
.Sp
The optional argument \fI\f(CI$flags\fI\fR consists of any combination of the flags below in the specified order.
.Sp
.Vb 3
\&  n   normalize $rx to CWB canonical form (NFC)
\&  c   case\-insensitive
\&  d   ignore diacritics (combining marks)
.Ve
.Sp
Admissible values for \fI\f(CI$type\fI\fR are thus \f(CW\*(C`c\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`cd\*(C'\fR, \f(CW\*(C`n\*(C'\fR, \f(CW\*(C`nc\*(C'\fR, \f(CW\*(C`nd\*(C'\fR and \f(CW\*(C`ncd\*(C'\fR.  The \f(CW\*(C`n\*(C'\fR flag is highly-recommended for regular expressions provided by users.
.Sp
\&\fBregex2id\fR returns an empty list if \fI\f(CI$rx\fI\fR does not match any types or if there are any errors, in particular in case of an invalid regular expression.  Unless strict modes is enabled, Perl scripts need to check \fB\fBCWB::CL::error_message()\fB\fR in order to catch syntax errors in \fI\f(CI$rx\fI\fR.
.IP "\fI\f(CI$f\fI\fR = \fI\f(CI$att\fI\fR\->idlist2freq(\fI\f(CI@ids\fI\fR);" 4
.IX Item "$f = $att->idlist2freq(@ids);"
Returns the total corpus frequency of all type IDs in the list \fI\f(CI@ids\fI\fR (\fBundef\fR if any of the lexicon IDs is out of range or another error occurs).  Equivalent to
.Sp
.Vb 2
\&  use List::Util qw(sum);
\&  $f = sum($att\->id2freq(@ids));
.Ve
.Sp
but much faster because the summation is carried out in C code.
.IP "\fI\f(CI@cpos\fI\fR = \fI\f(CI$att\fI\fR\->idlist2cpos(@ids);" 4
.IX Item "@cpos = $att->idlist2cpos(@ids);"
Look up all corpus positions annotated with one of the type IDs in \fI\f(CI@ids\fI\fR, merged into a single numerically sorted list.  Returns an empty list if there is any error.
.Sp
There is no separate method for the occurrences of a single type \fI\f(CI$id\fI\fR, but \fBidlist2cpos\fR recognises this special case and uses more efficient code (because the occurrences can be looked up directly in the inverted index).  The undocumented method \fBid2cpos\fR is simply an alias for \fBidlist2cpos\fR.
.SH "Structural Attributes (CWB::CL::StrucAttrib)"
.IX Header "Structural Attributes (CWB::CL::StrucAttrib)"
Handles for s\-attributes are represented by objects of class \fBCWB::CL::StrucAttrib\fR.  They should never be constructed directly, but rather obtained from the \fBattribute\fR method of a corpus handle.
.IP "\fI\f(CI$n\fI\fR = \fI\f(CI$att\fI\fR\->max_struc;" 4
.IX Item "$n = $att->max_struc;"
Returns the total number of regions for the s\-attribute.  Note that the name of the function is misleading: valid region numbers range from 0 to \fI\f(CI$n\fI\fR\-1.
.IP "\fI\f(CI$has_values\fI\fR = \fI\f(CI$att\fI\fR\->struc_values;" 4
.IX Item "$has_values = $att->struc_values;"
Returns \s-1TRUE\s0 if regions of this s\-attribute are annotated with string values.
.IP "\fI\f(CI$struc\fI\fR = \fI\f(CI$att\fI\fR\->cpos2struc(\fI\f(CI$cpos\fI\fR);" 4
.IX Item "$struc = $att->cpos2struc($cpos);"
.PD 0
.IP "\fI\f(CI@strucs\fI\fR = \fI\f(CI$att\fI\fR\->cpos2struc(\fI\f(CI@cpos\fI\fR);" 4
.IX Item "@strucs = $att->cpos2struc(@cpos);"
.PD
Returns the number of the region containing corpus position \fI\f(CI$cpos\fI\fR, or \fBundef\fR if \fI\f(CI$cpos\fI\fR is not inside a region of this s\-attribute (and in case of any errors, including out-of-bounds \fI\f(CI$cpos\fI\fR).
.Sp
It is not an error for \fI\f(CI$cpos\fI\fR to be outside a region, so \fBundef\fR will be returned even in strict mode.
.IP "\fI\f(CI$value\fI\fR = \fI\f(CI$att\fI\fR\->struc2str(\fI\f(CI$struc\fI\fR);" 4
.IX Item "$value = $att->struc2str($struc);"
.PD 0
.IP "\fI\f(CI@values\fI\fR = \fI\f(CI$att\fI\fR\->struc2str(\fI\f(CI@strucs\fI\fR);" 4
.IX Item "@values = $att->struc2str(@strucs);"
.PD
Obtain the string value that region number \fI\f(CI$struc\fI\fR is annotated with. Returns \fBundef\fR in case of any error, in particular if \f(CW\*(C`$att\->struc_values\*(C'\fR is \s-1FALSE.\s0
.Sp
Note that there is no method to search regions for a particular annotation string or regular expression.  Scripts will have to loop over all regions in the s\-attribute and carry out such tests in Perl code.
.IP "\fI\f(CI$value\fI\fR = \fI\f(CI$att\fI\fR\->cpos2str(\fI\f(CI$cpos\fI\fR);" 4
.IX Item "$value = $att->cpos2str($cpos);"
.PD 0
.IP "\fI\f(CI@values\fI\fR = \fI\f(CI$att\fI\fR\->cpos2str(\fI\f(CI@cpos\fI\fR);" 4
.IX Item "@values = $att->cpos2str(@cpos);"
.PD
Obtain the string value annotation of the region containing corpus position \fI\f(CI$cpos\fI\fR. Returns \fBundef\fR if \fI\f(CI$cpos\fI\fR is not inside any region of the s\-attribute (and in case of any errors, in particular if \f(CW\*(C`$att\->struc_values\*(C'\fR is \s-1FALSE\s0).  It is not an error for \fI\f(CI$cpos\fI\fR to be outside a region, so \fBundef\fR will be returned even in strict mode.
.Sp
This method is fully equivalent to
.Sp
.Vb 1
\&  @values = $att\->struc2str($att\->cpos2struc(@cpos));
.Ve
.Sp
but is faster and more convenient if the region numbers are not needed otherwise.  An alias \fBcpos2struc2str\fR is provided for consistency with the Corpus Library \s-1API,\s0 but \fBcpos2str\fR is the preferred form.
.IP "(\fI\f(CI$start\fI\fR, \fI\f(CI$end\fI\fR) = \fI\f(CI$att\fI\fR\->struc2cpos($struc);" 4
.IX Item "($start, $end) = $att->struc2cpos($struc);"
.PD 0
.IP "\fI\f(CI@pairs\fI\fR = \fI\f(CI$att\fI\fR\->struc2cpos(@strucs);" 4
.IX Item "@pairs = $att->struc2cpos(@strucs);"
.PD
Returns start and end corpus position of region number \fI\f(CI$struc\fI\fR, or \f(CW\*(C`(undef, undef)\*(C'\fR if there is any error.
.Sp
If multiple region numbers are supplied, a flast list of start/end pairs is returned (possibly containing pairs of \fBundef\fRs).  For example, the call \f(CW\*(C`@pairs = $att\->struc2cpos($n1, $n2, $n3);\*(C'\fR returns
.Sp
.Vb 1
\&  @pairs = ($s1, $e1, $s2, $e2, $s3, $e3);
.Ve
.IP "(\fI\f(CI$start\fI\fR, \fI\f(CI$end\fI\fR) = \fI\f(CI$att\fI\fR\->cpos2struc2cpos($cpos);" 4
.IX Item "($start, $end) = $att->cpos2struc2cpos($cpos);"
.PD 0
.IP "\fI\f(CI@pairs\fI\fR = \fI\f(CI$att\fI\fR\->cpos2struc2cpos(@cpos);" 4
.IX Item "@pairs = $att->cpos2struc2cpos(@cpos);"
.PD
Returns start and end corpus position of the region containing corpus position \fI\f(CI$cpos\fI\fR, or \f(CW\*(C`(undef, undef)\*(C'\fR if \fI\f(CI$cpos\fI\fR is not within a region of the s\-attribute (and for any error).  For multiple \fI\f(CI@cpos\fI\fR, the method returns a flat list of start/end pairs like \fBstruc2cpos\fR.
.Sp
It is not an error for \fI\f(CI$cpos\fI\fR to be outside a region, so \f(CW\*(C`(undef, undef)\*(C'\fR pairs will be returned even in strict mode.
.IP "if (\fI\f(CI$att\fI\fR\->cpos2is_boundary(\fI\f(CI$which\fI\fR, \fI\f(CI$cpos\fI\fR)) { ... }" 4
.IX Item "if ($att->cpos2is_boundary($which, $cpos)) { ... }"
.PD 0
.IP "\fI\f(CI@yesno\fI\fR = \fI\f(CI$att\fI\fR\->cpos2is_boundary(\fI\f(CI$which\fI\fR, \fI\f(CI@cpos\fI\fR);" 4
.IX Item "@yesno = $att->cpos2is_boundary($which, @cpos);"
.PD
Test whether corpus position \fI\f(CI$cpos\fI\fR is at the boundary of, inside or outside a region of s\-attribute \fI\f(CI$att\fI\fR. Returns \s-1TRUE\s0 if the test succeeds, \s-1FALSE\s0 otherwise, and \fBundef\fR in case of an error.
.Sp
The parameter \fI\f(CI$which\fI\fR determines which test is carried out.  The following short and long codes are supported:
.Sp
.Vb 6
\&  i   inside      cpos is anywhere inside a region
\&  o   outside     cpos is not inside a region
\&  l   left        cpos is the first token in a region
\&  r   right       cpos is the last token in a region
\&  lr  leftright   cpos is a single\-token region (first AND last)
\&  rl  rightleft   (same)
.Ve
.Sp
There is no single test for whether \fI\f(CI$cpos\fI\fR is either the start or the end of a region.  For this and other complex tests, the method \fBcpos2boundary\fR can be used.
.IP "\fI\f(CI$flags\fI\fR = \fI\f(CI$att\fI\fR\->cpos2boundary(\fI\f(CI$cpos\fI\fR);" 4
.IX Item "$flags = $att->cpos2boundary($cpos);"
.PD 0
.IP "\fI\f(CI@flags\fI\fR = \fI\f(CI$att\fI\fR\->cpos2boundary(\fI\f(CI@cpos\fI\fR);" 4
.IX Item "@flags = $att->cpos2boundary(@cpos);"
.PD
Returns an integer \fI\f(CI$flags\fI\fR where several flag bits can be set indicating whether \fI\f(CI$cpos\fI\fR is at the left/right boundary of, and/or inside a region.  Currently three bits are in use
.Sp
.Vb 3
\&  $CWB::CL::Boundary{"inside"}  set if $cpos is inside region
\&  $CWB::CL::Boundary{"left"}    set if $cpos is the first token of a region
\&  $CWB::CL::Boundary{"right"}   set if $cpos is the last token of a region
.Ve
.Sp
Use logical bit operators to test for individual flags or combinations of these flags.  For example, at the start of a region both \f(CW\*(C`inside\*(C'\fR and \f(CW\*(C`left\*(C'\fR bits will be set.  A \fI\f(CI$cpos\fI\fR outside a region returns \f(CW\*(C`$flags = 0\*(C'\fR.  And an \*(L"inner\*(R" token inside a region (which is neither the first nor last token) has only the \f(CW\*(C`inside\*(C'\fR bit set.
(Note: The \f(CW\*(C`leftright\*(C'\fR test in \fBcpos2is_boundary\fR checks whether all three bits are set.)
.SH "Alignment Attributes (CWB::CL::AlignAttrib)"
.IX Header "Alignment Attributes (CWB::CL::AlignAttrib)"
Handles for a\-attributes are represented by objects of class \fBCWB::CL::AlignAttrib\fR.  They should never be constructed directly, but rather obtained from the \fBattribute\fR method of a corpus handle.
.IP "\fI\f(CI$n\fI\fR = \fI\f(CI$att\fI\fR\->max_alg;" 4
.IX Item "$n = $att->max_alg;"
Returns the total number of alignment beads for the a\-attribute.  Note that the name of the function is misleading: valid bead numbers range from 0 to \fI\f(CI$n\fI\fR\-1.
.IP "\fI\f(CI$ok\fI\fR = \fI\f(CI$att\fI\fR\->has_extended_alignment;" 4
.IX Item "$ok = $att->has_extended_alignment;"
Returns \s-1TRUE\s0 if the a\-attribute uses \*(L"extended\*(R" format.  There is no difference in access patterns, but the script has to expect crossing alignments and gaps between beads if \fI\f(CI$ok\fI\fR is \s-1TRUE.\s0  Most aligned corpora will be in extended format.
.IP "\fI\f(CI$bead\fI\fR = \fI\f(CI$att\fI\fR\->cpos2alg(\fI\f(CI$cpos\fI\fR);" 4
.IX Item "$bead = $att->cpos2alg($cpos);"
.PD 0
.IP "\fI\f(CI@beads\fI\fR = \fI\f(CI$att\fI\fR\->cpos2alg(\fI\f(CI@cpos\fI\fR);" 4
.IX Item "@beads = $att->cpos2alg(@cpos);"
.PD
Returns the number of the alignment bead containing corpus position \fI\f(CI$cpos\fI\fR, or \fBundef\fR if \fI\f(CI$cpos\fI\fR is not inside a bead of this a\-attribute (and in case of any errors, including out-of-bounds \fI\f(CI$cpos\fI\fR).
.Sp
It is not an error for \fI\f(CI$cpos\fI\fR to be outside a bead (provided that the a\-attribute uses \*(L"extended\*(R" format), so \fBundef\fR will be returned even in strict mode.
.IP "(\fI\f(CI$src_start\fI\fR, \fI\f(CI$src_end\fI\fR, \fI\f(CI$tgt_start\fI\fR, \fI\f(CI$tgt_end\fI\fR) = \fI\f(CI$att\fI\fR\->alg2cpos($bead);" 4
.IX Item "($src_start, $src_end, $tgt_start, $tgt_end) = $att->alg2cpos($bead);"
.PD 0
.IP "\fI\f(CI@quads\fI\fR = \fI\f(CI$att\fI\fR\->alg2cpos(@beads);" 4
.IX Item "@quads = $att->alg2cpos(@beads);"
.PD
Returns the aligned spans in source and target corpus for alignment bead number \fI\f(CI$bead\fI\fR, or \f(CW\*(C`(undef, undef, undef, undef)\*(C'\fR if there is any error.
.Sp
If multiple bead numbers are supplied, a flast list of quadruplets is returned (possibly containing quadruplets of \fBundef\fRs).  For example, the call \f(CW\*(C`@quads = $att\->alg2cpos($A, $B);\*(C'\fR returns
.Sp
.Vb 1
\&  @quads = ($A_s1, $A_s2, $A_t1, $A_t2, $B_s1, $B_s2, $B_t1, $B_t2);
.Ve
.IP "(\fI\f(CI$src_start\fI\fR, \fI\f(CI$src_end\fI\fR, \fI\f(CI$tgt_start\fI\fR, \fI\f(CI$tgt_end\fI\fR) = \fI\f(CI$att\fI\fR\->cpos2alg2cpos($cpos);" 4
.IX Item "($src_start, $src_end, $tgt_start, $tgt_end) = $att->cpos2alg2cpos($cpos);"
.PD 0
.IP "\fI\f(CI@quads\fI\fR = \fI\f(CI$att\fI\fR\->cpos2alg2cpos(@cpos);" 4
.IX Item "@quads = $att->cpos2alg2cpos(@cpos);"
.PD
Returns the aligned source and target spans for the alignment bead containing corpus position \fI\f(CI$cpos\fI\fR, or \f(CW\*(C`(undef, undef, undef, undef)\*(C'\fR if \fI\f(CI$cpos\fI\fR is not inside a bead of this a\-attribute (and in case of any errors, including out-of-bounds \fI\f(CI$cpos\fI\fR).
.Sp
If multiple corpus positions are supplied, a flast list of quadruplets is returned in the same way as for \fBalg2cpos\fR.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
The minimalistic example script below requires the \f(CW\*(C`DICKENS\*(C'\fR demo corpus to be installed in the standard registry path.  It compiles a lemma frequency list for all \f(CW\*(C`<title>\*(C'\fR regions in the corpus and prints the first 20 entries.  Note how it uses \fBCWB::CL::Strict\fR to avoid checking return values for error conditions.
.PP
.Vb 1
\&  use CWB::CL::Strict;
\&   
\&  my $C = new CWB::CL::Corpus "DICKENS";
\&  my $Lemma = $C\->attribute("lemma", "p");
\&  my $Title = $C\->attribute("title", "s");
\&   
\&  my $n_titles = $Title\->max_struc;
\&  my %F = ();
\&   
\&  foreach my $i (0 .. ($n_titles \- 1)) {
\&    my ($start, $end) = $Title\->struc2cpos($i);
\&    foreach my $lemma ($Lemma\->cpos2str($start .. $end)) {
\&      $F{$lemma}++;
\&    }
\&  }
\&   
\&  my @lemmas = sort {$F{$b} <=> $F{$a}} keys %F;
\&  foreach my $lemma (@lemmas[0 .. 19]) {
\&    printf "%8d %s\en", $F{$lemma}, $lemma;
\&  }
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1999\-2022 by Stephanie Evert [https://purl.org/stephanie.evert]
.PP
This software is provided \s-1AS IS\s0 and the author makes no warranty as to
its use and performance. You may use the software, redistribute and
modify it under the same terms as Perl itself.
